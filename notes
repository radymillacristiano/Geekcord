Desafios

[X] Não carregar imagem de user com menos de 2 caracteres
[] Usar api do github para mostrar mais infos do user
[] Colocar botão de envio no chat
[] Colocar botão de excluir mensagem
[] Mostrar o loading de mensagens
[] Efeito de passar o mouse em cima (referência: https://pt-br.reactjs.org/docs/events.html#mouse-events)

Paulo: Perfeito! Agora basta pegar o dado, porque ele retorna um data. Mas, talvez nem seja necessário pegar o data. Quando acontece isso, podemos pegar todas as mensagens do banco de dados. Pode ser assim também, não? Mas ele vai trazer só um que foi inserido.

Mario: Isso! Vou pegar oQueVeio.

function escutaMensagensEmTempoReal() {
return supabaseClient
.from('mensagens')
.on('INSERT', (oQueVeio) => {
console.log('Houve uma nova mensagem', oQueVeio);
})
.subscribe();
}
```

**Paulo:** Vamos dar um `console.log()` nele para sabermos o que ele devolve.

**Mario:** Vamos tentar pegar as coisas com mais clareza. No Chat, vamos escrever "nova msg". No Console, aparece, `new` e é nele que está o `texto: "nova msg"`. Da mesma maneira, se digitarmos no Chat "Agora vai", no `new` teremos o `texto: "Agora vai"`. Se verificarmos a outra aba do localhost, o Console está mostrando os dois textos.

Então, para fecharmos esse assunto e testarmos, na prática, esses processos acontecendo, vamos pegar o `new` e passaremos uma função que é o `adicionaMensagem`. Estamos usando a mesma lógica de inverter os controles para fazer o `adicionaMensagem()` receber o `new`.

function escutaMensagensEmTempoReal(adicionnaMensagem) { return supabaseClient .from('mensagens') .on('INSERT', (new) => { adicionaMensagem(new); }) .subscribe(); }

````
Paulo: É porque o adicionaMensagem está na parte de dentro e nós não conseguiremos acessar de fora sem passar.

Mario: Exato! Um detalhe que apareceu agora: tivemos um problema com esse trecho de código, mais especificamente com o new em .on('INSERT', (new) => {, porque ele é uma palavra-chave. Então, podemos corrigir substituindo por .on('INSERT', (respostaLive) => { e, embaixo, por adicionaMensagem(respostaLive.new);.

function escutaMensagensEmTempoReal(adicionnaMensagem) {
   return supabaseClient
	      .from('mensagens')
				.on('INSERT', (respostaLive) => {
				   adicionaMensagem(respostaLive.new);
				})
				.subscribe();
	}

	```

Quem chama, isto é, quem quer escutar a mensagem, `escutaMensagensEmTempoReal()`, precisa executar algo quando essa mensagem chega. No nosso caso, vamos passar a nossa função para quem escuta. O `onclick` e o `escutaMensagens()` têm a mesma lógica. Sendo que, no primeiro, disparamos a função e, no segundo, queremos executar a mensagem.

Vamos pegar o `handleNovaMensagem()`. Nós passaremos a função abaixo, chamada da mesma maneira que a função `adcionaMensagem`. Ela vai receber a mensagem nova, `adicionaMensagem(respostaLive.new)`, vai para o trecho abaixo de novo, recebe em `escutaMensagensEmTempoReal((novaMensagem) => {` e joga na tela, `handleNovaMensagem(novaMensagem)`.

escutaMensagensEmTempoReal((novaMensagem) => { handleNovaMensagem(novaMensagem) }); }, []);


Vamos retornar ao Chat e recarregar a página. Vamos escrever no campo de mensagem do Chat "Será que deu certo?" e enviar apertando "Enter". Ele "explodiu". Tivemos um *loop* infinito. Paulo, não dá para terminar o dia com tudo perfeito, esses erros acontecem e poderiam ter acontecido com quem está em casa também. Aconteceu comigo e é até bom, porque quem está acompanhando o curso consegue acompanhar em que parte errei.

Eu coloquei um comando para que toda vez que tivéssemos uma nova mensagem, ele cadastrasse.

escutaMensagensEmTempoReal((novaMensagem) => { console.log(novaMensagem); //handleNovaMensagem(novaMensagem) }); }, []);


A lógica é, basicamente, se escrevemos "ola" no Chat, ele cadastra no Back-End e joga na tela. Mas, toda vez que temos uma nova mensagem, estamos, de novo, cadastrando, por isso entramos em um *loop* infinito recadastrando as mensagens e geramos mil e quinhentas escritas. De certa maneira foi bom para atestarmos que o banco de dados aguenta bastante informação.

Agora, no momento em que estamos fazendo `handleNovaMensagem(mensagem)`, pegamos o `insert`, deixaremos de fazer a parte do `setListadeMensagens([`.

]) .then(({ data }) => { // console.log('Criando mensagem: ', data); setListaDeMensagens([ data[0], ...listaDeMensagens, ]); });

setMensagem('');

}


Nós faremos apenas o `insert` na página e, ao invés de fazer o `handleNovaMensagem(novaMensagem)` para cadastrar, temos que atualizar a lista. Faz sentido?

**Paulo:** Sim, do contrário estaríamos adicionando de novo e fazendo outro `insert`.

**Mario:** O `handleNovaMensagem()` vai parar de atualizar a lista. Vamos comentar essa parte.

]) //.then(({ data }) => { // // console.log('Criando mensagem: ', data); // setListaDeMensagens([ // data[0], // ...listaDeMensagens, // ]); // });

setMensagem('');

}


Ao salvar,acontece o erro do "textarea". Vamos resolver no Terminal.

aluracord git:(aula05) yarn dev

yarn run v1.22.17

Em seguida, recarregaremos a página e escreveremos, no campo de mensagem do Chat, "Teste". Não está indo mais. Vamos até o `escutaMensagensEmTempoReal((novaMensagem)`, em teoria, a mensagem nova deveria estar nesse trecho.

escutaMensagensEmTempoReal((novaMensagem) => { console.log('Nova mensagem', novaMensagem); //handleNovaMensagem(novaMensagem) }); }, []);


Vamos fazer um novo teste no Chat, "Nova mensagem". Não funcionou de novo. Faltou rodarmos ao menos o `.then`, por isso, vamos voltar com esse trecho, tirando apenas a lista. Precisamos do `.then` para disparar o cadastro.

]) .then(({ data }) => { // console.log('Criando mensagem: ', data); //setListaDeMensagens([ // data[0], // ...listaDeMensagens, //]); });

setMensagem('');

}


Outra vez no Chat, vamos escrever "oi". No Console, percebemos que o criando nova mensagem está na ilha 58. É o que fazíamos antes. Mas, ao invés de fazer o 7 da lista ou de chamar o `handleNovaMensagem()`, que foi o meu erro, precisamos apenas rodar o código acima que pegará a mensagem nova com o que existia da lista.

Então, quem vai gerenciar a atualização da tela não é mais o `handleNovaMensagem()`, será esse outro pedaço abaixo, apenas com esse trecho de código e não todo o código de nova mensagem.

escutaMensagensEmTempoReal((novaMensagem) => { console.log('Nova mensagem', novaMensagem); setListaDeMensagens([ data[0], ...listaDeMensagens, ]); }); }, []);


**Paulo:** Só ele?

**Mario:** Sim, tudo que já existia na lista de mensagens com a nova mensagem. Foi o meu erro fatal que fez com que acontecesse das mensagens ficarem se subscrevendo. Então, estamos escutando a mensagem em tempo real. Sempre que tiver uma nova, jogamos na lista. De volta à página, vamos carregar e escrever "Oi Paulo". No Console, perceberemos que ele pegou apenas a nossa mensagem que aparece agora, `de: "omariosouto"`.

Existe um segredo no React que é importante mencionar. Ele carrega a página com as mensagens no Chat, quando escrevemos, por exemplo, "Nova Mensagem", apenas essa aparece e somem as outras. O motivo é que quando registramos o "escutador", `escutaMensagensEmTempoReal((novaMensagem)`, ele pega o valor inicial da lista, que é o valor vazio. Nós estamos registrando tudo e ele salva esse valor. O React não está avisando a esse pedaço de código que as coisas mudaram.

escutaMensagensEmTempoReal((novaMensagem) => { console.log('Nova mensagem', novaMensagem); setListaDeMensagens([ data[0], ...listaDeMensagens, ]); }); }, []);


Para garantir que teremos de mensagens atualizada, ao invés de apenas passar o *array*, nós o tiraremos, passaremos uma função e retornaremos o valor.

escutaMensagensEmTempoReal((novaMensagem) => { console.log('Nova mensagem', novaMensagem); setListaDeMensagens(() => { return [ novaMensagem, ...listaDeMensagens ] ]); }); }, []);


Isso porque o `setListaDeMensagens())`, recebendo uma função, sempre passará o valor atual que ele tem da lista. Portanto, teremos o `valorAtualDaLista`, que será o valor da lista de mensagens que está mais abaixo.

**Paulo:** Normalmente, nós passávamos um valor para o `set`, não uma função. Nós sempre trabalhamos com *setter* de *state* passando o valor direto. Agora não, nós estamos passando um tipo de função que recebe o valor da lista atual e o que ele deve fazer com ela para retornar a nova lista. Eu não entendi porque antes não funcionava. Você poderia comentar e mostrar como era antes, deixando um do lado do outro, para que seja possível comparar?

**Mario:** Sim, com certeza.

escutaMensagensEmTempoReal((novaMensagem) => { console.log('Nova mensagem', novaMensagem); console.log('listaDeMensagens:', listaDeMensagens); setListaDeMensagens([ novaMensagem, ...listaDeMensagens ]) // setListaDeMensagens((valorAtualDaLista) => { // return [ // novaMensagem, // ...valorAtualDaLista, // ] // ]); // }); }, []);


Salvamos e vamos recarregar a página. Agora, escreveremos no campo de mensagem do Chat "crirei uma nova mensagem". No Console, é possível notar que o `listaDeMensagens: []`  é um *array* vazio. É antes de rodar o `setState()`. O `listaDeMensagens`, como nós registramos essa função para ser rodada sempre que existir uma mensagem nova, ela pega a versão inicial do *array*. Quer dizer que ela pega a primeira foto que o React tirou.

**Paulo:** Entendi! Primeira foto do React e não do banco de dados, porque a foto que o React tirou era vazia. Correto?

**Mario:** Isso! É essa primeira, `React.useState([]);` que passamos no seguinte trecho.

export defautl function ChatPage() { const roteamento = useRouter(); const usuarioLogado = roteamento.query.username; const [mensagem, setMensagem] = React.useState(''); const [listaDeMensagens, setListaDeMensagens] = React.useState([]);

````

Paulo: Outra solução seria, nesta parte, carregar do banco de dados ao invés de passá-la vazia. Quando criamos a mágica do .useState(), dizemos: "React, a lista de mensagens é uma coisa mágica que você cuida e o valor inicial dela é vazio". O problema é justamente esse, como é vazia, na hora em que ele faz a primeira atualização, ele atualiza vazia para o primeiro insert que aconteceu, apagando o que aparecia no começo.

Mario: O nosso "escutador" não sabe que a variável mudou. Ele cria a função, guarda na memória e fica esperando. Quando chega o momento de executar, ele executa com o valor inicial que ele tinha.

Paulo: Há outras maneiras de mudar e resolver?

Mario: Sim, mas o mais comum, que as pessoas da documentação recomendam, é quando caímos nesse caso em que //Quero reusar um valor de referência (objeto/array), nós também precisamos // Passar uma função pro setState. Portanto, liberamos o código de novo e, ao carregar a página, se escrevemos no Chat "Teste", funciona.

escutaMensagensEmTempoReal((novaMensagem) => {
console.log('Nova mensagem', novaMensagem);
console.log('listaDeMensagens:', listaDeMensagens);
//Quero reusar um valor de referencia (objeto/array)
//Passar uma função pro setState
//setListaDeMensagens([
// novaMensagem,
// ...listaDeMensagens
// ])
setListaDeMensagens((valorAtualDaLista) => {
return [
novaMensagem,
...valorAtualDaLista,
]
]);
});
}, []);

A lista de mensagens que estava na linha 40 ainda está vazia, porque está considerando a primeira versão, mas se pegarmos o valor da lista atualizado, o React nos apresenta tudo que já existe. Esse é sim um assunto um pouco mais avançado, mas como estamos construindo um Chat que lida com inscrição de evento e outros conteúdos, é válido aprendermos, até porque, é um problema que pode aparecer no nosso dia a dia.

Além disso, é importante passarmos por todo o processo, tanto errar, quanto ajustar, corrigir o código e assim por diante.

Paulo: Eu sempre fico bravo nas Imersões em que o Mario, na última aula, avança muito nos conteúdos, mas esse é um ponto que exemplifica bem a maneira como a Alura ensina e a importância do Dev em T. Não podemos o nosso aprendizado a uma cópia dos conteúdos das aulas, é necessário envolvimento, precisamos aprender como tudo funciona.

Por isso, durante a imersão, eu pedi que o Mario retomasse o passo a passo, porque ele fez e já continuou. Esse "faz e já vai" é porque o Mario já conhece, nós precisamos fazer e entender o que estamos fazendo. Entender por que funcionou e porque não funcionou.

Esse é o caso dessa aula, em que investigamos por que ele "limpou" o Chat naquele momento. Descobrimos que está relacionado com o userFact e com o useState, mais especificamente porque ele não é uma variável comum, existe o hook que aciona uma série de elementos. Enfim, para compreendermos o React e conseguirmos trabalhar com ele, precisamos dominar o useState e os hooks.

Até o mecanismo antigo de classe - que não aprendemos nessa aula, não havia necessidade - precisa ser entendido, porque, do contrário, apenas copiaremos e colaremos os conteúdos, ou arriscaremos alguns comandos sem compreendê-los de fato. Nós não desejamos ter esse perfil Dev, queremos compreender bem os conteúdos e seus usos.

Claro que nas primeiras vezes nos confundimos, é complicado mesmo, mas precisamos sempre parar e buscar compreender. As nossas formações na Alura são organizadas assim, tanto que algumas pessoas perguntam o motivo de insistirmos em determinado assunto, e a resposta é que, em algum momento, será necessário entender o que está por trás dos conteúdos, inclusive, será necessário, em algum momento, ler o Código-fonte de um componente.

Mesmo tendo uma boa compreensão da biblioteca, dos componentes e conseguindo fazer o visual rapidamente, em algum momento da carreira, para ser pleno, sênior ou principal, é preciso ter esse domínio.

Mario: Paulo, eu gostaria de comentar sobre um caso bem banal. Muitas pessoas acham que se criamos dois arrays e comparamos, vai dar true. Esse problema que aconteceu aqui é exatamente a explicação do porquê comparar dois arrays não dá true.

Existe uma versão do array que é a primeira que carregamos e que aquela função salvou na memória, em algum lugar do JavaScript. Nas outras vezes em que o React foi reexecutando a função, o nosso "escutador" só gerou na primeira vez. Ele não sabe o que aconteceu depois com esse valor, porque o React sempre está gerando um novo valor, sempre estamos gerando um novo array.

Isso exige um pouco mais de conhecimento da linguagem, mas quando temos a base da linguagem, caímos em um corner case e pensamos no motivo dele ter acontecido: existe arrays, cada um com uma referência, o React sempre gera um novo, guardou a primeira referência e não a última. Desta maneira, conseguimos ter um domínio maior do que está acontecendo.

Paulo: Perfeito. Agora, poderíamos abrir a outra tela e mostrar que com o login do Paulo também conseguimos escrever.

Mario: Certo, vamos duplicar a página do Chat, fazer o logout, apertar "Inspect" para que a página e Console fiquem dispostos lado a lado. Preencheremos o campo de login com "peas", em seguida, apertaremos o botão "Entrar" para acessar o Chat.

Paulo: Agora temos duas abas de Chat. O Paulo entrou e pegou as mensagens do Mario. Tudo que escrevemos no Chat com o login do Paulo, em teoria, na hora em que chegar no supabase, o React saberá que alguém inseriu e que existia uma pessoa fazendo subscribe nesse mecanismo de mensagem, publisher-subscriber.

No mecanismo de mensagerias o termo subscribe é comum, quer dizer que "eu quero ouvir essa fila de mensagens/acontecimentos".

Mario: Eu escrevi no campo de mensagens "Tudo que eu escrever aqui óh! Em teoria ele aciona na hora que chega lá no supabase ele vai ver que alguém inseriu e tinha alguém fazendo subscribe... esse lance de Pub e Sub", apertei "Enter".

Paulo: A mensagem que você escreveu apareceu no Chat em que eu estou logado. Vamos até o Chat que está com o seu login.

Mario: A mensagem apareceu também. Agora você "deployar" isso na Vercel e compartilhar o seu sistema do Aluracord no Discord - é um metaverso - para que possamos comentar, conversar com você, criar um Chat real, enfim, as pessoas perceberão que você foi além do sticker e tem upload de áudio e muitos outros elementos.

Nós fizemos um ótimo projeto, um "projetaço" envolvendo Back-End as a service, estudando os uses, router, effect, state, que é o que você usará no dia a dia do Next.js e React. Estamos, de fato, estudando conteúdos que são úteis no nosso cotidiano e com muitos detalhes.

A parte em que mais copiamos e colamos foi a do CCS, para que ficasse mais bonito, o resto nós fizemos do zero. Pegamos um componente do Mario, analisamos, alteramos, criamos o nosso listener, fomos muito além.

Estamos chegando ao final da Imersão. Acho que foram cinco aulas incríveis. Gostaria de reforçar o convite de que, até a segunda-feira, você faça os projetos. Nós queremos ver os melhores! Na segunda-feira, durante a live das 18h30, nós mostraremos os projetos incríveis que encontramos. Quem sabe não chamamos alguém para contar um pouco do projeto.

Também falaremos da nossa formação Next.js nova, sobre o andamento dela, o que o Mario está trazendo, "linkaremos" com a formação React que tem Bugan e outros instrutores, também relacionaremos com a formação JavaScript para Back-End que está sendo lançada na Alura.

Enfim, temos um ecossistema completo de Node.js, Back-End, para quem deseja se tornar aluna/aluno. Mas não se matricule hoje na Alura, porque teremos um desconto na segunda-feira e durante a semana para quem participou da Imersão. Temos muitas novidades esse ano.

Se você chegou ao final de semana com o conteúdo completo, que sabemos que é muita coisa, tem um vídeo hoje, sexta-feira, no canal do Dev Soutinho, em que ele discute um pouco mais subscribe e unsubscribe.

Também discute sobre a possibilidade de nos conectarmos ao Back-End de outra pessoa com o nosso Front-End e analisar se o nosso com o de outra pessoa, que é completamente diferente, se integram minimamente e temos uma API em comum. Algo assim. O Mario mostrará nesse vídeo o que é possível fazer para ir além desse projeto do Aluracord que está muito bacana mesmo!

Estou muito feliz em ver o que você está trazendo, acompanhar as discussões no Discord e por ajudarmos as comunidades de Next.js e React, "fazer barulho" com o fundador da Vercel e com o fundador do Supabase. Esse momento de uma Imersão da Alura é incrível, nós teremos outras em diversos modelos e assuntos, porque desejamos expandir o Aluraverso e trazer você para ele.

Mario: Perfeito, Paulo! Acho que isso mesmo! Nós estamos sempre trazendo muitos conteúdos e te convidamos a interagir conosco, sugerindo, inclusive. Nós queremos te ouvir para conseguir trazer conteúdos bacanas e, a partir dos feedbacks, ir moldando a Imersão para que ela aconteça de acordo com o que vocês acham que seria interessante ter.

Nós sabemos o que queremos trazer, mas sempre podemos somar elementos à nossa visão. Queremos fazer tudo em conjunto e que vocês sejam parte do Aluraverso.

Paulo: Até a próxima Imersão! Até a live de segunda-feira, 18h30. Tchau!!

Mario: Tchau, tchau!!
